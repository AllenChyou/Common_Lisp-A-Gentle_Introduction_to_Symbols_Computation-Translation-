---
layout: post
title: "学习Lisp-第三章-EVAL标记法-A"
categories: Lisp
excerpt:
tags: Lisp CommonLisp 翻译
---

* content
{:toc}

《Common Lisp 符号计算简单介绍》第三章 EVAL标记法 上半部分





## 第三章 EVAL标记法

### 3.1 导引

在进一步深入学习Lisp之前，我们必须切换到一个更加适合的标记法，EVAL标记法。不再使用矩形来表示函数，而是使用列表。矩形图示是很容易理解，但是EVAL表示法有以下几个优点：

- 一些复杂到不能用矩形图示来表示的编程概念，可以用EVAL表示式来表达。

- EVAL图示是很方便就可以够用键盘敲击来输入的，盒形图示就不行。

- 从数学的角度来看，使用一般列表来表示函数是非常优雅的，因为我们可以确定使用同一种表达式来表示函数和
数据。

- 在Lisp中，数据就是函数，EVAL表示可以允许我们定义函数来接受其它函数作为输入。我们将在第7章介绍这个
特性。

- 当你精通了EVAL表达式，那也就是掌握了用Lisp和电脑交流的方式。

### 3.2 EVAL函数

EVAL函数是Lisp的核心。主要的作用就是求Lisp表达式的数值并且计算结果。大部分表达式是由一个函数和一些输入组成的，假如给EVAL函数输入（+ 2 3），他就会调用内建函数+来处理输入2和3.并且+函数返回数值5，因此我们会说，表达式（+ 2 3）的值是5。

![](http://ww3.sinaimg.cn/mw690/8d6a2535jw1el7mjmoa2xj208102x0sj.jpg)

从现在开始，我们就不再画一个EVAL函数的矩形了，而是使用一个箭头来表示。

```
(+ 2 3) → 5
```

如果使用两个箭头的话，会显得稍稍冗长一些。

![](http://ww1.sinaimg.cn/mw690/8d6a2535jw1el7mm8exm5j206603b0sj.jpg)

想要展现更多细节的话，就会使用三箭头的图形表示。

![](http://ww4.sinaimg.cn/mw690/8d6a2535jw1el7mncn3obj20cw0423yi.jpg)

细线和粗线代表的意思等一会儿再解释，我们先来看一些EVAL表达式的例子。

```
(+ 1 6) → 7
(oddp (+ 1 6)) → t
(* 3 (+ 1 6)) → 21
(/ (* 2 11) (+ 1 6)) → 22/7
```

### 3.3 EVAL表达式可以做到矩形表达式所做的任何事

很明显，矩形表达式能够表示的表达式，那么EVAL表达式也能够做到。
比如下面的表达式就可以写成

![](http://ww2.sinaimg.cn/mw690/8d6a2535jw1el7mqmssfaj20m40bswel.jpg)

类似的EVAL表达式也可以写成矩形表达

```
(* 3 (+ 5 6))
(not (equal 5 6))
```

![](http://ww2.sinaimg.cn/mw690/8d6a2535jw1el7mtuwpbuj20kx0763yi.jpg)

你可能注意到了，矩形表达式和EVAL表达式读起来正好是相反的顺序，矩形表达式的顺序应该是，5，6，EQUAL，NOT。相对应的EVAL表达式的读法是NOT，EQUAL，5，6.在矩形表达式中，计算式从左向右的计算顺序。在EVAL表达式中一个函数的输入是从左向右这么被处理的。但是对于嵌套结构的表达式来说，求数值的真正过程是从最深处的表达式开始从内向外的计算顺序，使得函数调用的顺序是从右向左的。

### 3.4 求值规则定义EVAL函数的行为

EVAL函数的运行是伴随一系列求值规则的。其中一个规则就是数字和其他确定的对象是自求值的，意思就是自己求自己的值。特殊字符串T和NIL也是自求值的。

```
23 → 23
t → t
nil → nil
```

数字，T，NIL的求值规则：数字，字符串T，NIL是自求值的。

也有规则是针对列表的。列表的第一个元素将会定义一个待调用的函数；剩余的元素是函数的非求值参数。这些元素必须是被求值，从左到右的顺序来决定函数的输入。例如，求值表达式（ODDP （+ 1 6）），首先要做的就是求值ODDP函数的参数，列表（+ 1 6）。为了实现求值这个参数，我们开始求值函数+的参数。1求值得1,6求值得6,。现在我们可以调用函数+使用这些输入得出结果7，7就是作为函数ODDP的输入，然后返回结果T。

列表的求值规则：列表的第一个元素就定义了一个待调用的函数，余下的元素就是这个函数的参数。调用函数操作这些已求值的参数。

以下图示是称作求值回溯图（evaltrace diagram），展示了列表（ODDP （+ 1 6））是如何求值的。请注意求值过程是从内部嵌套的表达式（+ 1 6）开始，到外层表达式，ODDP函数结束。这种由内而外的性质是由求值回溯图的形状来反映。

![](http://ww1.sinaimg.cn/mw690/8d6a2535jw1el7mytn74cj20ex0b1aak.jpg)

这里有另一个在函数调用之前，参数被求值的例子，表达式（EQUAL （+ 7 5） （* 2 8））的求值回溯图。

![](http://ww1.sinaimg.cn/mw690/8d6a2535jw1el7mzx6etuj20gy0gggmn.jpg)

##### 练习

- 3.1 列表（NOT （EQUAL 3 （ABS  -3）））的求值结果是？
- 3.2 用EVAL表达式来写一个表达式，8加上12再除以2.
- 3.3 一个数的平方可以让这个数乘以自己来求得，写一个EVAL表达式来求3的平方加上4的平方。
- 3.4 画出下列EVAL表达式的求值回溯图。

```
(- 8 2)
(not (oddp 4))
(> (* 2 5) 9)
(not (equal 5 (+ 1 4)))
```

### 3.5 用EVAL表达式定义函数

在矩形表达式中，我们通过表现内部的具体细节来定义一个函数。函数的输入被描绘成为箭头，在EVAL表达式中，我们使用列表来定义函数，通过变量名字来指向函数的参数。我们可以命名矩形表达式的输入通过在箭头上写上名字的方式。

![](http://ww1.sinaimg.cn/mw690/8d6a2535jw1el83tliuvpj20ob0fhjrv.jpg)

以EVAL表达式来定义AVERAGE函数
```
(defun average (x y)
       (/ (+ x y) 2.0))
```

DEFUN函数是一类特殊的函数，名字叫做宏函数（macro function），规定他的参数并不是要求值的，所以宏函数不是一定要被引用的。DEFUN函数的作用是用来定义其它函数。第二个元素是参数列表，也就是定义将会用到的参数的名字。剩下的元素就是DEFUN函数定义的函数体（body），函数的内部细节。另外DEFUN这个名字是define的缩写。

只要在计算机中定义函数AVERAGE一次，就可以使用EVAL表达式来调用AVERAGE函数。比如这样调用，（AVERAGE 6 8），AVERAGE函数就会使用6作为X的值，8作为Y的值来进行计算，最后得出结果7。
这里还有一个defun定义函数的例子

```
(defun square (n) (* n n))
```

函数名叫做square，参数列表是（n），也就是接受一个指向n的参数。函数提示表达式（* n n），理解这个定义的正确方式是定义一个n的square的函数，返回n的平方。

除了特殊字符串T和NIL之外，几乎所有的字符串都可以作为函数的参数名使用，x，y，n一般是最常用的，但是bozo，artichoke等等也是可以的。一个计算贸易成本的函数可能给函数参数的命名就是quantity，price，和handling-charge。

```
(defun total-cost (quantity price handling-charge)
(+ (* quantity price) handling-charge))
```

### 3.6 变量（variables）

变量（variable）是数据存储的地方。我们再来看average函数。当我们调用average函数，Lisp创造了两个变量来存储输入，之后函数体中的表达式会根据参数名来指向这个变量。这些变量的名字就是x和y。很重要的一点就是辨析清楚变量和字符串之间的区别。变量不是字符串，变量是通过字符串来命名的，函数也是通过字符串命名。

变量的值就是所存储的数据。当我们对列表（average 3 7）求值的时候，Lisp创造出变量x和y，并且给他们分别赋值，3和7.在average函数的函数体中，字符串x指向第一个变量，字符串y指向第二个变量。这些变量也只能在函数体内部被引用，在average函数外部就不能引用了。当然字符串x和y在函数外部仍然存在，但是与在函数内部的意思已经完全不同，下面的求值回溯图很好地说明了计算结果的过程：

![](http://ww4.sinaimg.cn/mw690/8d6a2535jw1el84chvnpnj20h10hi75d.jpg)

术语“变量“的使用是计算机编程中特有的，在数学里，一个变量的意思是一个未知数据的意思，不是一个计算机内存中的数据。但是这两个方面的意思也并不是完全对立，一个函数的输入在函数定义的时候也的确是未知的一个数据

现在，我们可以解释求值回溯图中粗箭头和细箭头的意思了。细箭头是用表达式的值连接起来的。一个粗箭头是被用在暂时进入以一个函数内部的函数体和从函数体中出来，得到结果的过程。在粗箭头包括的范围内，我们见到的是函数内部的运行情况。在average函数的函数体中，变量被创造，表达式被求值。对于像+或者/这类函数，因为他们是原始函数，所以我们没什么机会用粗箭头来看他们内部的情况。对于用于定义的函数average，我们可以由一个细箭头开始表示表达式函数调用，然后中间表示粗箭头来展现函数体。下面用抽象语法来展现这种表达方式：

![](http://ww3.sinaimg.cn/mw690/8d6a2535jw1el84e2rvktj20mc092js5.jpg)

求值回溯表达式是十分灵活的：如果需要可以隐去不必要的细节，比如不展示函数体。另一个简化求职回溯过程的方法是不展示数字的求值，既然数字都是自求值的。有时候也省略字符串的求值。下图是ONEMOREP函数的一般简要格式的回溯图:

![](http://ww2.sinaimg.cn/mw690/8d6a2535jw1el84f9njfcj20hk0bgdgi.jpg)

### 3.7 对字符串求值

一个函数给自己参数使用的名字和其它函数使用的参数名字是互相独立的。两个函数，比如half和square函数都可以叫他们的参数n，但是在函数half中的n只是指向half函数的输入，与square函数中的n没有任何关系。

EVAL表示法中对于字符串的规则是很简单的：对于字符串的求值规则：一个字符串的值就是变量指向的数据。

在函数half和square的函数体之外，字符处啊n指向的就是全局变量（global variable）n。全局变量就是和任何函数都没有关系的变量。PI作为Common Lisp的内建变量就是一个全局变量的例子。

```
pi → 3.14159
```

Lisp程序员有时候非正式讨论变量求值的时候，他们会说变量求他们的值，真正的意思是一个字符串求他所指向的变量的值，既然有许许多多变量都被称作n，那么n指向甚么值就看变量n在什么地方出现了。假如出现是在square函数的函数体内部，那么得到的变量就是函数square的输入，假如出现在函数体外部，那么得到的就是全局变量n

假如你求的变量还没有被赋值，Lisp就会报错，变量未赋值错误（unassigned variable error）。比如，在内建变量中，并没有一个佳作eggplant的变量。那对字符串eggplant的求值就会报变量未赋值错误。当然，除非在某函数的内部对这个字符串求值，指向某一个输入。

```
eggplant → Error! EGGPLANT unassigned variable.
```

Common Lisp中也没有叫做n的内建变量，所以在函数half和square的函数体外部求n的值也是会报同样的错误。

### 3.8 将字符串和列表作数据使用

假设我们想要调用函数equal，并且将字符串kirk和spock作为输入。在矩形表达式中这是很方便的，因为字符串和列表总是被当做数据看待。但是在EVAL表达式中，字符串是被看做具名变量的，所以假如我们写成这样。

```
(equal kirk spock)
```

Lisp将会认为我们尝试比较的是两个名字叫kirk和spock的全局变量的值。既然给不出这样两个变量的值，那就会报错。

```
(equal kirk spock) → Error! KIRK unassigned variable.
```

我们真正想要比较的不是变量的值，而是字符串本身，我们告诉Lisp，这个两个字符串不是变量的引用而是作为数据看待，只要在字符串前面加上一个单引号就好了。

```
(equal ’kirk ’spock) → nil
```

因为字符串T和NIL都是被求值为自己，所以不需要用单引号来标记他们，其他字符串需要这么标记。

```
(list ’james t ’kirk) → (james t kirk)
```

一个字符串是否在函数定义中被看做数据，或者在函数输入中被略过，为了防止被求值，就必须加上前面的单引号。

```
(defun riddle (x y)
(list ’why ’is ’a x ’like ’a y))

(riddle ’raven ’writing-desk) → (why is a raven like a writing-desk)
```

列表在被当做数据看的时候也必须加引号，不然就会被Lisp求值，一个典型的结果就是报错，未定义函数错误（undefined function）。

```
(first (we hold these truths)) → Error! WE undefined function.
(first ’(we hold these truths)) → we
```

对引用对象的求值规则：一个被引用的对象求值为自己本身。

这里有一些加引号和没加引号的列表，之间的区别很明显

```
(third (my aunt mary)) → Error! MY undefined function.
(third ’(my aunt mary)) → mary
(+ 1 2) → 3
’(+ 1 2) → (+ 1 2)
(oddp (+ 1 2)) → t
(oddp ’(+ 1 2)) → Error! Wrong type input to ODDP.
```

最后一个例子出错的原因是oddp被调用的时候，列表（+ 1 2）的值需要作为输入。引号的出现使得列表的求值被绕过，oddp接收到的是列表而不是数字，oddp的输入必须是数字，不能是列表。

现在我们来看一下有引号存在的求值回溯过程

![](http://ww4.sinaimg.cn/mw690/8d6a2535jw1el84qaog43j20o30a0gmw.jpg)

### 3.9 错误引用问题

对于Lisp程序员来说，很容易就对引号感到困惑，而且引号的使用有时候不是放错地方就是在需要的地方少用了引号。Lisp提供的错误信息有时候是很好的关于错误的提示。一个未赋值变量错误或者一个未定义函数错误通常都显示是一个引号被遗漏的原因。

```
(list ’a ’b c) → Error! C unassigned variable.
(list ’a ’b ’c) → (a b c)
(cons ’a (b c)) → Error! B undefined function.
(cons ’a ’(b c)) → (a b c)
```

另一方面来说，输入类型错误或者意想不到的输出结果也可能是一个引号放错了位置的表示。

```
(+ 10 ’(- 5 2)) → Error! Wrong type input to +.
(+ 10 (- 5 2)) → 13
(list ’buy ’(* 27 34) ’bagels) → (buy (* 27 34) bagels)
(list ’buy (* 27 34) ’bagels) → (buy 918 bagels)
```

给一个列表加上引号，放在列表外面的目的是为了防止列表被求值。如果引号被放在列表里面的话，EVAL表达式就会尝试对列表进行求值，结果就是错误的。

```
(’foo ’bar ’baz) → Error! ’FOO undefined function.
’(foo bar baz) → (foo bar baz)
```

### 3.10 构造列表的三种方式

有三种方式来通过EVAL表达式来构造列表。可以吧列表直接写出来，然后前加引号防止被求值

```
’(foo bar baz) → (foo bar baz)
```

或者我们可以使用list和cons函数来为独立元素构造一个列表，假如我们使用这个方法，我们需要把每一个元素都前加引号。

```
(list ’foo ’bar ’baz) → (foo bar baz)
(cons ’foo ’(bar baz)) → (foo bar baz)
```

使用这种方法的一个好处就是，在构成列表的元素时，可以有一些是被当时计算出来的而不是直接定义的。

```
(list 33 ’squared ’is (* 33 33)) → (33 squared is 1089)
```

如果整个列表是被直接引用的话，那么列表内部的所有元素都不会被求值。

```
’(33 squared is (* 33 33)) → (33 squared is (* 33 33))
```

我们也已经见过一些引号没有被正确使用的情况

```
(list foo bar baz) → Error! FOO unassigned variable.
(foo bar baz) → Error! FOO undefined function.
(’foo ’bar ’baz) → Error! ’FOO undefined function.
```
